{"meta":{"title":"Yet Another Blog","subtitle":null,"description":null,"author":"Xinwei Gao","url":"https://if2007.github.io"},"pages":[{"title":"categories","date":"2018-04-03T13:41:42.000Z","updated":"2018-04-03T13:46:39.075Z","comments":true,"path":"categories/index.html","permalink":"https://if2007.github.io/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-04-03T13:28:47.000Z","updated":"2018-04-06T11:53:40.371Z","comments":true,"path":"about/index.html","permalink":"https://if2007.github.io/about/index.html","excerpt":"","text":"@card{ 教育背景：北京交通大学智能交通数据安全与隐私保护技术北京市重点实验室攻读博士学位，信息安全专业。预计毕业后进入工业界工作 实习经历：2013.9-2014.6 @ 密码科学技术国家重点实验室 论文发表：博士攻读期间发表 SCI（CCF-A 类）和 EI 期刊 + 会议论文数篇 研究兴趣：后量子密钥交换、TLS (HTTPS)、CDN 安全防护、隐私保护、数据安全 主要技能：公钥（基于 LWE/RLWE 的格密码）和对称密码算法研究、优化、实现；常用开源库及二次开发；TLS (HTTPS) 开发；Windows &amp; Linux 下 C/C++/Java 开发；雅思 7.0；$\\LaTeX$ 联系邮箱：xinwei.gao.7@yandex.com 获取 PGP Key 请联系我获取 CV。 }"},{"title":"History","date":"2018-04-04T10:54:08.578Z","updated":"2018-04-04T10:54:08.577Z","comments":false,"path":"history/index.html","permalink":"https://if2007.github.io/history/index.html","excerpt":"","text":"@timeline{ 2018@item{ 2018.4https://if2007.github.io基于 Hexo 和 GitHub Pages 的 Blog 重新上线 } @item{ 2018.3重新上线 Blog 的想法萌发 } 2016@item{ 2016.9https://if2007.github.io基于 Hexo 和 GitHub Pages 的 Blog 首次上线 } @item{ 2016.8准备搭建基于 GitHub Pages 和 Hexo 的 Blog } }"},{"title":"Tags","date":"2018-04-03T13:15:30.000Z","updated":"2018-04-03T14:48:35.395Z","comments":true,"path":"tags/index.html","permalink":"https://if2007.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 GmSSL 库 s_client/s_server 测试国密 SSL 握手","slug":"gmssl_certificate_s_client_s_server","date":"2018-06-03T16:00:00.000Z","updated":"2018-06-14T12:39:36.802Z","comments":true,"path":"2018/06/04/gmssl_certificate_s_client_s_server/","link":"","permalink":"https://if2007.github.io/2018/06/04/gmssl_certificate_s_client_s_server/","excerpt":"","text":"2018.6.14 更新 - 国密 SSL 握手成功根据 GmSSL Issue #503 下 liclicli 同学提供的方法，已经可以使用 GmSSL Commit 0adf4ce188bde5f9bdfcdf2b5859b1f0c687e64f 编译生成的二进制文件成功进行国密 SSL 的握手，使用的套件为 SM2-WITH-SM4-SM3。 首先使用 TASSL 开源国密 SSL 库中的证书生成脚本生成一系列证书，包括 CA、客户端加密/签名和服务器端加密/签名证书。方法很简单，即运行 Tassl_demo/mk_tls_cert 下的 SM2certgen.sh 脚本，共生成 15 个 PEM 文件 复制需要的证书和密钥。这里我们以 SM2-WITH-SM4-SM3 套件为例，因此需要以下证书和密钥：SS.cert.pem、SS.key.pem、SE.cert.pem、SE.key.pem，其中 SS 开头的是服务器端签名用的，SE 开头的是服务器端加密用的。由于国密 SSL 的双证书体系，要注意两个不同的证书 客户端命令：./gmssl s_client -connect localhost:4333 -msg -debug -gmtls –state；服务器端命令：./gmssl s_server -gmtls -accept 4333 -cert SS.cert.pem -key SS.key.pem -dcert SE.cert.pem -dkey SE.key.pem -msg -debug –state Done! 特别鸣谢 liclicli 同学的帮助 握手成功的输出： 123456789101112131415161718192021---New, GMTLSv1.1, Cipher is SM2-WITH-SMS4-SM3Server public key is 256 bitSecure Renegotiation IS NOT supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : GMTLSv1.1 Cipher : SM2-WITH-SMS4-SM3 Session-ID: B77C271E6FD1A86E5E15135BC7EE23B1EFAAD86A5EA1947EB8AF1D9A48275771 Session-ID-ctx: Master-Key: 645913A47210C8A389790267C328F867EDA4711D8FB163AD67CDF9310683FCD7181A21489A61BB1CD8B4DA429DBAEF7D PSK identity: None PSK identity hint: None SRP username: None Start Time: 1528979823 Timeout : 7200 (sec) Verify return code: 21 (unable to verify the first certificate) Extended master secret: no--- 看到正确的握手和输出简直泪奔啊┭┮﹏┭┮ 本文参考 GmSSL GitHub 的 Issue #8 下的一个不完整的解决方法，结合自己的摸索实践和填坑，给出一套完整的：用gmssl命令生成 CA 证书、客户端证书、服务器端证书，并用s_client和s_server命令进行交互测试的过程。 准备工作与 GmSSL GitHub 的 Issue #8 类似，首先执行下面的命令： 12345mkdir demoCAcd demoCA/mkdir certs crl newcerts privatetouch index.txtecho \"01\" &gt; serial 生成一系列证书CA 自签名证书利用gmssl命令行工具，生成自签名的 CA 证书和 key，并进行自签名。这里，我们的证书使用 SM2 椭圆曲线算法和 SM3 哈希算法生成的： 123../gmssl ecparam -genkey -name sm2p256v1 -out cakey.pem // 生成 key../gmssl req -new -sm3 -key cakey.pem -out cacsr.pem // 生成 CSR../gmssl req -x509 -sm3 -days 3650 -key cakey.pem -in cacsr.pem -out cacert.pem // 自签名 用../gmssl x509 -in cacert.pem -text查看一下生成的 CA 证书。 将 cakey.pem 文件移动至 private 目录下，cakey.pem 文件仍然在 demoCA 目录下。 生成客户端和服务器端 Key 和 CSR1234./gmssl ecparam -genkey -name sm2p256v1 -out client_key.pem./gmssl req -new -sm3 -key client_key.pem -out client_csr.pem./gmssl ecparam -genkey -name sm2p256v1 -out server_key.pem./gmssl req -new -sm3 -key server_key.pem -out server_csr.pem 注意，生成 CSR 时，命令行中提示的信息需要填写。不填写的话，会在签发证书时提示 Common Name 缺失。 用 CA 证书对客户端和服务器端 CSR 进行证书签发注意，这里是填坑最大的地方。按以前的步骤操作，总会出现各种各样奇怪的错误。在进行无数的搜索和测试后，我找到了以下可以 work 的方法： ./gmssl ca -md sm3 -in client_csr.pem -out client_cert.pem -days 3650 -policy policy_anything 类似的，对服务器端：./gmssl ca -md sm3 -in server_csr.pem -out server_cert.pem -days 3650 -policy policy_anything。 最重要的就是-policy policy_anything部分。这个是用于解决The stateOrProvinceName field needed to be the same in the CA certificate xxx and the request xxx的问题。有人说可以修改openssl.cnf文件中的string_mask为pkix值，但在 commit 值为 0adf4ce188bde5f9bdfcdf2b5859b1f0c687e64f 的 GmSSL 库中（2018.5.27）无法 work。 s_client 和 s_server 命令行测试与 OpenSSL 的命令行一致，可以用以下 GmSSL 命令行进行客户端和服务器端的模拟测试： 12./gmssl s_server -key server_key.pem -cert server_cert.pem -accept 4333./gmssl s_client -key client_key.pem -cert client_cert.pem -connect localhost:4333 问题目前会出现以下错误： 服务器端： 123456789$./gmssl s_server -key server_key.pem -cert server_cert.pem -accept 4333Using default temp DH parameters[GMTLS_DEBUG] set sm2 encryption certificate[GMTLS_DEBUG] set sm2 decryption private keyACCEPTERROR139670675003136:error:1417A0C1:SSL routines:tls_post_process_client_hello:no shared cipher:ssl/statem/statem_srvr.c:1502:shutting down SSLCONNECTION CLOSED 客户端： 1234567891011121314151617181920212223242526272829303132$./gmssl s_client -key client_key.pem -cert client_cert.pem -connect localhost:4333[GMTLS_DEBUG] set sm2 encryption certificate[GMTLS_DEBUG] set sm2 decryption private keyCONNECTED(00000003)139947870295808:error:14094410:SSL routines:ssl3_read_bytes:sslv3 alert handshake failure:ssl/record/rec_layer_s3.c:1385:SSL alert number 40---no peer certificate available---No client certificate CA names sent---SSL handshake has read 7 bytes and written 62 bytesVerification: OK---New, (NONE), Cipher is (NONE)Secure Renegotiation IS NOT supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : GMTLSv1.1 Cipher : 0000 Session-ID: Session-ID-ctx: Master-Key: PSK identity: None PSK identity hint: None SRP username: None Start Time: 1528099250 Timeout : 7200 (sec) Verify return code: 0 (ok) Extended master secret: no--- 目前错误原因未知。 希望本文能对你有所帮助，也希望能一起讨论存在的问题。","categories":[{"name":"GmSSL","slug":"GmSSL","permalink":"https://if2007.github.io/categories/GmSSL/"}],"tags":[{"name":"GmSSL","slug":"GmSSL","permalink":"https://if2007.github.io/tags/GmSSL/"}]},{"title":"常用的 Git 命令备忘","slug":"my_git_commands_sheet","date":"2018-06-02T16:00:00.000Z","updated":"2018-06-14T05:52:11.206Z","comments":true,"path":"2018/06/03/my_git_commands_sheet/","link":"","permalink":"https://if2007.github.io/2018/06/03/my_git_commands_sheet/","excerpt":"","text":"本文记录了自己常用的 Git 命令，以便日后快速查找 一行查看 Git commit 历史：git log --pretty=oneline 彻底退回某一次 Commit（源代码回退）：git reset --hard [commit_id] 不彻底回退某一次 Commit（commit 信息回退，代码不变）：git reset --soft [commit_id] 切换至某一分支：git checkout [branch_name] 查看所有分支名称：git branch -a 添加上游仓库：git remote add upstream [git@...../xxx.git] 从上游仓库获取更新：git fetch upstream 从上游仓库获取更新，需要将代码手动合并进来：git merge [branch_name]，例如upstream/branch_name 将本地分支 a 的更新提交至远程的分支 b：git push origin [a]:[b] 查看以前的操作：git reflog 移除上游：git remote rm [upstream_name] 提交本地的 test 分支作为远程的 test 分支：git push origin test:test Git 不会主动追踪变更的文件，需要 git add 才能被追踪到 将 Add 和 Commit 合并为一步：git commit -am [Commit msg] Git 克隆一个 fork 分支并同步原仓库的更新 添加所有改变了的文件：git add -u 强制 push：git push -f 修改某次提交：git commit --amend 两次 commit 的差别统计信息：git diff [commit_a_id] [commit_b_id] --stat 撤销已 push 到远端的 commit，保留本地文件的修改，并重新提交至远端，达到覆盖掉以前提交的 commit 的效果：git reset --soft [commit_id]; git commit -am &quot;comment&quot;; git push origin [branch_name] --force","categories":[{"name":"Git","slug":"Git","permalink":"https://if2007.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://if2007.github.io/tags/Git/"}]},{"title":"Git 克隆一个 fork 分支并同步原仓库的更新","slug":"git_sync_upstream","date":"2018-05-30T16:00:00.000Z","updated":"2018-06-01T03:48:33.449Z","comments":true,"path":"2018/05/31/git_sync_upstream/","link":"","permalink":"https://if2007.github.io/2018/05/31/git_sync_upstream/","excerpt":"","text":"本文记录如何从 Git 克隆一个仓库，切换到一个分支，添加上游仓库，同步上游的更新至本地（本地自己做的更新不会被上游的更新覆盖掉）。 克隆远程仓库 git clone git@xxx/openssl.git 查看所有分支 git branch -a 切换到某个分支 git checkout xxx 查看远程状态 git remote -v 添加远程的仓库。这里添加的仓库就是你期望从哪个仓库更新他们新提交的代码并合并到你的分支里的那个 git remote add upstream https://......git 确认是否配置成功 git remote -v 此时应该有 4 行 从上游仓库获取新的内容，同步到本地 git fetch upstream 新的内容会被存储在一个本地 upstream/master 中 Git 基础 - 远程仓库的使用: git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。 切换到本地主分支 (optional) git checkout master 将 upstream/master 分支合并到 master 上。此时，已经完成了同步，且不会丢掉本地修改的代码 git merge upstream/master 感谢：https://www.zhihu.com/question/28676261/answer/44606041","categories":[{"name":"Git","slug":"Git","permalink":"https://if2007.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://if2007.github.io/tags/Git/"}]},{"title":"OpenSSL 生成证书并用 s_client/s_server 测试链接的命令","slug":"openssl_cert_client_server","date":"2018-05-30T16:00:00.000Z","updated":"2018-05-31T12:35:42.215Z","comments":true,"path":"2018/05/31/openssl_cert_client_server/","link":"","permalink":"https://if2007.github.io/2018/05/31/openssl_cert_client_server/","excerpt":"","text":"本文记录： 如何从 OpenSSL 源代码编译生成库文件 从 openssl 命令行生成一部分常用证书 用 s_server 命令自己搭建测试服务器，并用 s_client 链接 注：本文测试的 OpenSSL 版本为 1.1.0 和更新的 1.1.1+。 OpenSSL 编译相关配置 OpenSSL，得到静态的可以 debug 的库./Configure -g linux-x86_64 --prefix=/home/.../openssl_1.1.0h/install --openssldir=/home/.../openssl_1.1.0h no-shared no-threads enable-crypto-mdebug enable-crypto-mdebug-backtrace 动态库则去掉no-shared参数。 在测试机上，使用 make -j进行编译，生成动态库 14 秒，静态库 19 秒。 生成 RSA 证书并用命令行测试服务器 (s_server)/客户端 (s_client)生成证书12345./openssl genrsa -out server.key 1024./openssl req -key server.key -new -out server.rsq./openssl req -in server.rsq -text % 以可读的形式查看生成的证书签发请求 (CSR)./openssl x509 -req -in server.rsq -signkey server.key -out server.pem -days 365./openssl x509 -in server.pem –text % 以可读的形式查看生成的证书 (自签名) 注意在生成证书时，可以指定使用的哈希函数。例如国密算法中可以使用 SM3 算法，则在 GmSSL 库中，可以用如下命令： ./gmssl req -new -sm3 -key ca.key -out ca.req s_client 和 s_server 模拟测试客户端-服务器端通信12./openssl s_client -connect localhost:4333./openssl s_server -key server.key -cert server.pem -accept 4333 -4 填坑在我的测试环境中和OpenSSL 1.1.0+ 版本中，必须要带-4参数才可正常开启服务器端，即强制使用 ipv4。否则则出现下面的错误： 12345678910111213141516Using default temp DH parametersACCEPT0:error:02004061:system library:socket:unknown:crypto/bio/b_sock2.c:49:0:error:2008C076:BIO routines:BIO_socket:unable to create socket:crypto/bio/b_sock2.c:50: 0 items in the session cache 0 client connects (SSL_connect()) 0 client renegotiates (SSL_connect()) 0 client connects that finished 0 server accepts (SSL_accept()) 0 server renegotiates (SSL_accept()) 0 server accepts that finished 0 session cache hits 0 session cache misses 0 session cache timeouts 0 callback cache hits 0 cache full overflows (128 allowed) GDB 调试此时可以用 gdb 进行调试： 123$ gdb -q -args ./openssl s_server -key server.key -cert server.pem -accept 4333(gdb) b BIO_socket(gdb) r","categories":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://if2007.github.io/categories/OpenSSL/"}],"tags":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://if2007.github.io/tags/OpenSSL/"}]},{"title":"NIST 后量子密码标准征集提案 - Ding Key Exchange","slug":"nist_pqc","date":"2018-04-05T16:00:00.000Z","updated":"2018-04-06T11:50:49.782Z","comments":true,"path":"2018/04/06/nist_pqc/","link":"","permalink":"https://if2007.github.io/2018/04/06/nist_pqc/","excerpt":"","text":"后量子密码 (Post-quantum Cryptography) 及背景1994 年，Peter Shor 提出了著名的量子算法。Shor 的量子算法可以实现：当足够大的量子计算机存在时，一些数论中的困难问题可以被有效解决，例如：离散对数问题（及其椭圆曲线版本），并可以被用于分解大整数。注意到离散对数问题（及其椭圆曲线版本）和大整数分解问题是目前广泛应用的公钥密码学算法（Diffie-Hellman 密钥交换协议、RSA、椭圆曲线 (ECC) 等）的困难性的基础。在没有量子计算机和对应的算法时，现有的经典公钥密码算法配合较为合适的参数（例如 2048 比特的 RSA）可以被认为在一定时间内是安全的。但是，一旦大型的量子计算机成功建造，Shor 的算法被认为可以快速且完全攻破大多数目前使用的公钥密码算法，即使参数被显著增大 $^{[1]}$。 [1] 这里的“参数被显著增大”指的是在计算和通信开销可接受范围内的情况。当参数被“急剧增大”时，RSA 算法被认为可以“抵抗”量子计算机攻击。但此时，公钥的尺寸已经接近几百 M 甚至大于 1 GB。 在真实世界中，广泛应用于各类安全应用、协议中的密码学原语包括且不仅限于：公钥加密、数字签名、密钥交换等。基于所有的互联网服务都依赖于密码学算法，包括且不仅限于 TLS、HTTPS、SSH、邮件、电子商务、移动支付、数字货币等。所有网络、软件、系统、应用安全等所有现代互联网的应用都将受到严峻的挑战。 后量子密码学 (Post-quantum Cryptography) 的任务是构造可以抵抗经典和量子计算机攻击的新的密码学算法，以应对量子计算机对于密码学的威胁。主要的后量子密码学实现技术有：基于格 (Lattice-based)、基于哈希 (Hash-based) 、基于编码 (Code-based) 、基于多变量 (Multivariate-based) 、基于格 (Lattice-based) 等。这四种方法各有其利弊。目前认为，在上述四种实现后量子密码算法的技术中，基于格的密码算法可以实现最强的安全性、最小的总通信开销、最快的计算速度和最多样化的密码算法设计。 截至目前，Google 已对后量子密码学算法的实用性进行实际测试。Google 将后量子密钥交换协议应用于 TLS 中，并在 Google Chrome 浏览器的 Canary 分支和部分 Google Play 服务器上成功进行了测试。 您可以参考后量子密码学的 Wikipedia 页面、Nature 上的文章或较为系统的介绍后量子密码学的书等资源对后量子密码学进行更多的了解。您还可以参考这两篇较为详细的后量子密码学中文介绍：“从量子计算到量子安全”和“后量子密码技术发展分析”。 NIST 后量子密码标准征集工作2016 年 12 月 20 日，美国国家标准技术研究所 (National Institute of Standards and Technology, NIST) 正式宣布启动全世界范围内的后量子密码算法标准征集竞赛，旨在征集新一代的可以抵抗量子计算机攻击的公钥加密、数字签名和密钥交换协议。此竞赛欢迎全球范围内所有个人/组织向 NIST 提交密码算法的文档、工程实现。NIST 公开所有符合初步筛选标准的候选算法，供所有人进行分析和评论，利用所有人的力量共同制定新一代的密码学算法标准。 候选算法的征集工作已于 2017 年 11 月 30 日截止，共有来自 25 个国家的 82 个候选算法被提交，其中 69 个符合 NIST 的初步筛选标准。全部 69 个候选算法涵盖了基于格、多变量、编码和哈希等的后量子密码学算法构造。所有候选算法的文档已于 2017 年 12 月公布于 NIST 网站。 NIST 的后量子密码学专家 Dustin Moody 在 AsiaCrypt 2017 会议上对 NIST 的后量子密码标准征集竞赛和现状进行了详细的介绍。报告的 Slide 可以在这里下载。 Dustin Moody 报告 Slide 2018 年 4 月 NIST 于 Florida 的 Fort Lauderdale 举行第一届 NIST 后量子密码标准化会议。我很荣幸作为 “Ding Key Exchange” 团队的成员参会。 我参与的提案 “Ding Key Exchange”我们团队设计并实现了一个基于格问题 - RLWE (Ring Learning with Errors) 的密钥交换协议 “Ding Key Exchange”，并提交至 NIST 的后量子密码算法标准征集竞赛。算法的文档和工程实现可以在 NIST 网站下载。所有人都可以可以点击 “Submit Comment” 提交对算法的评价。提交的评价会发送至 NIST 的后量子密码算法讨论邮件列表。收到的评价可以点击 “View Comments” 查看。加入邮件列表的方法可以在这里找到。 Ding Key Exchange @ NIST 网站 我们设计的算法是可以抵抗量子计算机攻击的密钥交换协议（以下简称 DKE）。DKE 是经典的 Diffie-Hellman 密钥交换协议的后量子版本，即 DKE 的结构和 Diffie-Hellman 密钥交换协议完全一致。这为 DKE 的应用提供了极为便利的条件，即现有使用 Diffie-Hellman 密钥交换协议的安全应用、协议可以直接使用 DKE 进行代替现有算法以抵抗量子计算机攻击。此外，DKE 还有以下的优势： 通信开销小 计算速度快 前向安全（类比 Diffie-Hellman Ephemeral） 高于 AES-128/192/256 安全性的多样参数选择 DKE 协议的示意图如下所示： Ding Key Exchange 协议示意图 更为详细的 Ding Key Exchange 协议规范和介绍参见提交的文档。 写在最后我从 2017 年开始 NIST 后量子密码标准提案的准备工作。此时正值我在国外进行为期一年的公派联合培养。我极为荣幸能与 University of Cincinnati 的 Jintai Ding 教授、The University of Tokyo 的 Tsuyoshi Takagi 教授和 The University of Tokyo 的 Yuntao Wang 合作完成此 NIST 后量子密码标准提案。在提案的准备和提交过程中，我得到了他们大力和无私的全面帮助和支持，在此再次感谢他们！此外，还要感谢国家留学基金委对我为期一年的公派联合培养博士生项目的资助和支持。 希望未来 10-15 年内能看到后量子密码算法在真实世界中的广泛应用。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://if2007.github.io/categories/Crypto/"}],"tags":[{"name":"NIST","slug":"NIST","permalink":"https://if2007.github.io/tags/NIST/"},{"name":"Crypto","slug":"Crypto","permalink":"https://if2007.github.io/tags/Crypto/"},{"name":"Post-quantum","slug":"Post-quantum","permalink":"https://if2007.github.io/tags/Post-quantum/"},{"name":"Key Exchange","slug":"Key-Exchange","permalink":"https://if2007.github.io/tags/Key-Exchange/"}]}]}