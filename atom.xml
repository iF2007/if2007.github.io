<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yet Another Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://if2007.github.io/"/>
  <updated>2018-05-31T12:15:02.540Z</updated>
  <id>https://if2007.github.io/</id>
  
  <author>
    <name>Xinwei Gao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 克隆一个 fork 分支并同步原仓库的更新</title>
    <link href="https://if2007.github.io/2018/05/31/git_sync_upstream/"/>
    <id>https://if2007.github.io/2018/05/31/git_sync_upstream/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-05-31T12:15:02.540Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录如何从 Git 克隆一个仓库，切换到一个分支，添加上游仓库，同步上游的更新至本地（本地自己做的更新不会被上游的更新覆盖掉）。</p><ol><li>克隆远程仓库</li></ol><p><code>git clone git@xxx/openssl.git</code></p><ol start="2"><li>查看所有分支</li></ol><p><code>git branch -a</code></p><ol start="3"><li>切换到某个分支</li></ol><p><code>git checkout xxx</code></p><ol start="4"><li>查看远程状态</li></ol><p><code>git remote -v</code></p><ol start="5"><li>添加远程的仓库。这里添加的仓库就是你期望从哪个仓库更新他们新提交的代码并合并到你的分支里的那个</li></ol><p><code>git remote add upstream https://......git</code></p><ol start="6"><li>确认是否配置成功</li></ol><p><code>git remote -v</code></p><p>此时应该有 4 行</p><ol start="7"><li>从上游仓库获取新的内容，同步到本地</li></ol><p><code>git fetch upstream</code></p><p>新的内容会被存储在一个本地 upstream/master 中</p><ol start="8"><li>切换到本地主分支 (optional)</li></ol><p><code>git checkout master</code></p><ol start="9"><li>将 upstream/master 分支合并到 master 上。此时，已经完成了同步，且不会丢掉本地修改的代码</li></ol><p><code>git merge upstream/master</code></p><p><em>感谢：<a href="https://www.zhihu.com/question/28676261/answer/44606041" target="_blank" rel="noopener">https://www.zhihu.com/question/28676261/answer/44606041</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录如何从 Git 克隆一个仓库，切换到一个分支，添加上游仓库，同步上游的更新至本地（本地自己做的更新不会被上游的更新覆盖掉）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;克隆远程仓库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;git clone git@xxx/openssl.git&lt;
      
    
    </summary>
    
      <category term="Git" scheme="https://if2007.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://if2007.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL 生成证书并用 s_client/s_server 测试链接的命令</title>
    <link href="https://if2007.github.io/2018/05/31/openssl_cert_client_server/"/>
    <id>https://if2007.github.io/2018/05/31/openssl_cert_client_server/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-05-31T12:35:42.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录：</p><ol><li>如何从 OpenSSL 源代码编译生成库文件</li><li>从 openssl 命令行生成一部分常用证书</li><li>用 s_server 命令自己搭建测试服务器，并用 s_client 链接</li></ol><p>注：本文测试的 OpenSSL 版本为 1.1.0 和更新的 1.1.1+。</p><h2 id="OpenSSL-编译相关"><a href="#OpenSSL-编译相关" class="headerlink" title="OpenSSL 编译相关"></a>OpenSSL 编译相关</h2><h3 id="配置-OpenSSL，得到静态的可以-debug-的库"><a href="#配置-OpenSSL，得到静态的可以-debug-的库" class="headerlink" title="配置 OpenSSL，得到静态的可以 debug 的库"></a>配置 OpenSSL，得到静态的可以 debug 的库</h3><p><code>./Configure -g linux-x86_64 --prefix=/home/.../openssl_1.1.0h/install --openssldir=/home/.../openssl_1.1.0h no-shared no-threads enable-crypto-mdebug enable-crypto-mdebug-backtrace</code></p><p>动态库则去掉<code>no-shared</code>参数。</p><p>在测试机上，使用 <code>make -j</code>进行编译，生成动态库 14 秒，静态库 19 秒。</p><h2 id="生成-RSA-证书并用命令行测试服务器-s-server-客户端-s-client"><a href="#生成-RSA-证书并用命令行测试服务器-s-server-客户端-s-client" class="headerlink" title="生成 RSA 证书并用命令行测试服务器 (s_server)/客户端 (s_client)"></a>生成 RSA 证书并用命令行测试服务器 (s_server)/客户端 (s_client)</h2><h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./openssl genrsa -out server.key 1024</span><br><span class="line">./openssl req -key server.key -new -out server.rsq</span><br><span class="line">./openssl req -in server.rsq -text  % 以可读的形式查看生成的证书签发请求 (CSR)</span><br><span class="line">./openssl x509 -req -in server.rsq -signkey server.key -out server.pem -days 365</span><br><span class="line">./openssl x509 -in server.pem –text % 以可读的形式查看生成的证书 (自签名)</span><br></pre></td></tr></table></figure><p>注意在生成证书时，可以指定使用的哈希函数。例如国密算法中可以使用 SM3 算法，则在 <a href="https://github.com/guanzhi/GmSSL" target="_blank" rel="noopener">GmSSL</a> 库中，可以用如下命令：</p><p><code>./gmssl req -new -sm3 -key ca.key -out ca.req</code></p><h3 id="s-client-和-s-server-模拟测试客户端-服务器端通信"><a href="#s-client-和-s-server-模拟测试客户端-服务器端通信" class="headerlink" title="s_client 和 s_server 模拟测试客户端-服务器端通信"></a>s_client 和 s_server 模拟测试客户端-服务器端通信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./openssl s_client -connect localhost:4333</span><br><span class="line">./openssl s_server -key server.key -cert server.pem -accept 4333 -4</span><br></pre></td></tr></table></figure><h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><p>在我的测试环境中和OpenSSL 1.1.0+ 版本中，必须要带<code>-4</code>参数才可正常开启服务器端，即强制使用 ipv4。否则则出现下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Using default temp DH parameters</span><br><span class="line">ACCEPT</span><br><span class="line">0:error:02004061:system library:socket:unknown:crypto/bio/b_sock2.c:49:</span><br><span class="line">0:error:2008C076:BIO routines:BIO_socket:unable to create socket:crypto/bio/b_sock2.c:50:</span><br><span class="line">   0 items in the session cache</span><br><span class="line">   0 client connects (SSL_connect())</span><br><span class="line">   0 client renegotiates (SSL_connect())</span><br><span class="line">   0 client connects that finished</span><br><span class="line">   0 server accepts (SSL_accept())</span><br><span class="line">   0 server renegotiates (SSL_accept())</span><br><span class="line">   0 server accepts that finished</span><br><span class="line">   0 session cache hits</span><br><span class="line">   0 session cache misses</span><br><span class="line">   0 session cache timeouts</span><br><span class="line">   0 callback cache hits</span><br><span class="line">   0 cache full overflows (128 allowed)</span><br></pre></td></tr></table></figure><h3 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h3><p>此时可以用 gdb 进行调试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -q -args ./openssl s_server -key server.key -cert server.pem -accept 4333</span><br><span class="line">(gdb) b BIO_socket</span><br><span class="line">(gdb) r</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何从 OpenSSL 源代码编译生成库文件&lt;/li&gt;
&lt;li&gt;从 openssl 命令行生成一部分常用证书&lt;/li&gt;
&lt;li&gt;用 s_server 命令自己搭建测试服务器，并用 s_client 链接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：
      
    
    </summary>
    
      <category term="OpenSSL" scheme="https://if2007.github.io/categories/OpenSSL/"/>
    
    
      <category term="OpenSSL" scheme="https://if2007.github.io/tags/OpenSSL/"/>
    
  </entry>
  
  <entry>
    <title>NIST 后量子密码标准征集提案 - Ding Key Exchange</title>
    <link href="https://if2007.github.io/2018/04/06/nist_pqc/"/>
    <id>https://if2007.github.io/2018/04/06/nist_pqc/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-04-06T11:50:49.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后量子密码-Post-quantum-Cryptography-及背景"><a href="#后量子密码-Post-quantum-Cryptography-及背景" class="headerlink" title="后量子密码 (Post-quantum Cryptography) 及背景"></a>后量子密码 (Post-quantum Cryptography) 及背景</h1><p>1994 年，Peter Shor 提出了著名的量子算法。Shor 的量子算法可以实现：当足够大的量子计算机存在时，一些数论中的困难问题可以被有效解决，例如：离散对数问题（及其椭圆曲线版本），并可以被用于分解大整数。注意到离散对数问题（及其椭圆曲线版本）和大整数分解问题是目前广泛应用的公钥密码学算法（<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">Diffie-Hellman 密钥交换协议</a>、<a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">RSA</a>、<a href="https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6" target="_blank" rel="noopener">椭圆曲线 (ECC)</a> 等）的困难性的基础。在没有量子计算机和对应的算法时，现有的经典公钥密码算法配合较为合适的参数（例如 2048 比特的 RSA）可以被认为在一定时间内是安全的。但是，一旦大型的量子计算机成功建造，Shor 的算法被认为可以快速且完全攻破大多数目前使用的公钥密码算法，即使参数被显著增大 $^{[1]}$。</p><p><em>[1] 这里的“参数被显著增大”指的是在计算和通信开销可接受范围内的情况。当参数被“急剧增大”时，RSA 算法被认为可以“抵抗”量子计算机攻击。但此时，公钥的尺寸已经接近几百 M 甚至大于 1 GB。</em></p><p>在真实世界中，广泛应用于各类安全应用、协议中的密码学原语包括且不仅限于：公钥加密、数字签名、密钥交换等。基于所有的互联网服务都依赖于密码学算法，包括且不仅限于 TLS、HTTPS、SSH、邮件、电子商务、移动支付、数字货币等。所有网络、软件、系统、应用安全等所有现代互联网的应用都将受到严峻的挑战。</p><p>后量子密码学 (Post-quantum Cryptography) 的任务是构造可以抵抗经典和量子计算机攻击的新的密码学算法，以应对量子计算机对于密码学的威胁。主要的后量子密码学实现技术有：基于格 (Lattice-based)、基于哈希 (Hash-based) 、基于编码 (Code-based) 、基于多变量 (Multivariate-based) 、基于格 (Lattice-based) 等。这四种方法各有其利弊。目前认为，在上述四种实现后量子密码算法的技术中，基于格的密码算法可以实现最强的安全性、最小的总通信开销、最快的计算速度和最多样化的密码算法设计。</p><p>截至目前，Google 已对后量子密码学算法的实用性进行<a href="https://security.googleblog.com/2016/07/experimenting-with-post-quantum.html" target="_blank" rel="noopener">实际测试</a>。Google 将后量子密钥交换协议应用于 TLS 中，并在 Google Chrome 浏览器的 Canary 分支和部分 Google Play 服务器上成功进行了测试。</p><p>您可以参考后量子密码学的 <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography" target="_blank" rel="noopener">Wikipedia 页面</a>、<a href="https://www.nature.com/articles/nature23461" target="_blank" rel="noopener">Nature 上的文章</a>或<a href="https://www.springer.com/us/book/9783540887010" target="_blank" rel="noopener">较为系统的介绍后量子密码学的书</a>等资源对后量子密码学进行更多的了解。您还可以参考这两篇较为详细的后量子密码学中文介绍：<a href="http://www.knowfar.org.cn/html/zhanlue/201612/22/641.htm" target="_blank" rel="noopener">“从量子计算到量子安全”</a>和<a href="http://www.knowfar.org.cn/html/zhanlue/201701/13/657.htm" target="_blank" rel="noopener">“后量子密码技术发展分析”</a>。</p><h1 id="NIST-后量子密码标准征集工作"><a href="#NIST-后量子密码标准征集工作" class="headerlink" title="NIST 后量子密码标准征集工作"></a>NIST 后量子密码标准征集工作</h1><p>2016 年 12 月 20 日，美国国家标准技术研究所 (National Institute of Standards and Technology, NIST) <a href="https://csrc.nist.gov/news/2016/public-key-post-quantum-cryptographic-algorithms" target="_blank" rel="noopener">正式宣布</a>启动全世界范围内的后量子密码算法标准征集竞赛，旨在征集新一代的可以抵抗量子计算机攻击的公钥加密、数字签名和密钥交换协议。此竞赛欢迎全球范围内所有个人/组织向 NIST 提交密码算法的文档、工程实现。NIST 公开所有符合初步筛选标准的候选算法，供所有人进行分析和评论，利用所有人的力量共同制定新一代的密码学算法标准。</p><p>候选算法的征集工作已于 2017 年 11 月 30 日截止，共有来自 25 个国家的 82 个候选算法被提交，其中 69 个符合 NIST 的初步筛选标准。全部 69 个候选算法涵盖了基于格、多变量、编码和哈希等的后量子密码学算法构造。所有候选算法的文档已于 2017 年 12 月<a href="https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions" target="_blank" rel="noopener">公布于 NIST 网站</a>。</p><p>NIST 的后量子密码学专家 Dustin Moody 在 AsiaCrypt 2017 会议上对 NIST 的后量子密码标准征集竞赛和现状进行了详细的介绍。报告的 Slide 可以在<a href="https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/asiacrypt-2017-moody-pqc.pdf" target="_blank" rel="noopener">这里下载</a>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="nist_pqc_asiacrypt_17_slide.png" alt="Dustin Moody 报告 Slide" title="">                </div>                <div class="image-caption">Dustin Moody 报告 Slide</div>            </figure><p>2018 年 4 月 NIST 于 Florida 的 Fort Lauderdale 举行<a href="https://csrc.nist.gov/Events/2018/First-PQC-Standardization-Conference" target="_blank" rel="noopener">第一届 NIST 后量子密码标准化会议</a>。我很荣幸作为 “Ding Key Exchange” 团队的成员参会。</p><h1 id="我参与的提案-“Ding-Key-Exchange”"><a href="#我参与的提案-“Ding-Key-Exchange”" class="headerlink" title="我参与的提案 “Ding Key Exchange”"></a>我参与的提案 “Ding Key Exchange”</h1><p>我们团队设计并实现了一个基于格问题 - RLWE (Ring Learning with Errors) 的密钥交换协议 “Ding Key Exchange”，并提交至 NIST 的后量子密码算法标准征集竞赛。算法的文档和工程实现可以在<a href="https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions" target="_blank" rel="noopener"> NIST 网站下载</a>。所有人都可以可以点击 “Submit Comment” 提交对算法的评价。提交的评价会发送至 NIST 的后量子密码算法讨论邮件列表。收到的评价可以点击 “View Comments” 查看。加入邮件列表的方法<a href="https://csrc.nist.gov/Projects/Post-Quantum-Cryptography/Email-List" target="_blank" rel="noopener">可以在这里找到</a>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="dke_nist_website.png" alt="Ding Key Exchange @ NIST 网站" title="">                </div>                <div class="image-caption">Ding Key Exchange @ NIST 网站</div>            </figure><p>我们设计的算法是可以抵抗量子计算机攻击的密钥交换协议（以下简称 DKE）。DKE 是经典的<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener"> Diffie-Hellman 密钥交换协议</a>的后量子版本，即 <strong>DKE 的结构和 Diffie-Hellman 密钥交换协议完全一致</strong>。这为 DKE 的应用提供了极为便利的条件，即现有使用 Diffie-Hellman 密钥交换协议的安全应用、协议可以<strong>直接使用 DKE 进行代替现有算法以抵抗量子计算机攻击</strong>。此外，DKE 还有以下的优势：</p><ul><li>通信开销小</li><li>计算速度快</li><li>前向安全（类比 <a href="https://tls.mbed.org/kb/cryptography/ephemeral-diffie-hellman" target="_blank" rel="noopener">Diffie-Hellman Ephemeral</a>）</li><li>高于 AES-128/192/256 安全性的多样参数选择</li></ul><p>DKE 协议的示意图如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="dke_flow.png" alt="Ding Key Exchange 协议示意图" title="">                </div>                <div class="image-caption">Ding Key Exchange 协议示意图</div>            </figure><p>更为详细的 Ding Key Exchange 协议规范和介绍参见<a href="https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions" target="_blank" rel="noopener">提交的文档</a>。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我从 2017 年开始 NIST 后量子密码标准提案的准备工作。此时正值我在国外进行为期一年的公派联合培养。我极为荣幸能与 University of Cincinnati 的 <a href="http://www.artsci.uc.edu/departments/math/fac_staff.html?eid=dingji" target="_blank" rel="noopener">Jintai Ding</a> 教授、The University of Tokyo 的 <a href="http://crypto.mist.i.u-tokyo.ac.jp/en/" target="_blank" rel="noopener">Tsuyoshi Takagi</a> 教授和 The University of Tokyo 的 Yuntao Wang 合作完成此 NIST 后量子密码标准提案。在提案的准备和提交过程中，我得到了他们大力和无私的全面帮助和支持，在此再次感谢他们！此外，还要感谢<a href="http://www.csc.edu.cn/" target="_blank" rel="noopener">国家留学基金委</a>对我为期一年的公派联合培养博士生项目的资助和支持。</p><p>希望未来 10-15 年内能看到后量子密码算法在真实世界中的广泛应用。</p>]]></content>
    
    <summary type="html">
    
      对提交至 NIST 的后量子密码标准征集提案 - 基于 RLWE 问题的格密钥交换协议 &quot;Ding Key Exchange&quot; 的简单介绍
    
    </summary>
    
      <category term="Crypto" scheme="https://if2007.github.io/categories/Crypto/"/>
    
    
      <category term="NIST" scheme="https://if2007.github.io/tags/NIST/"/>
    
      <category term="Crypto" scheme="https://if2007.github.io/tags/Crypto/"/>
    
      <category term="Post-quantum" scheme="https://if2007.github.io/tags/Post-quantum/"/>
    
      <category term="Key Exchange" scheme="https://if2007.github.io/tags/Key-Exchange/"/>
    
  </entry>
  
</feed>
